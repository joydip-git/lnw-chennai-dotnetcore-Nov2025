Configuration Service:
------------------------------

1. setting files like app settings json file
2. environment variables
3. Command line arguments
4. Directory files
5. in memory objects
6. 3rd party providers
7. azure key vault
8. azure app config
etc.

configuration providers:
	json provider
	in memory provider
	environment variables provider
	etc.
Major interfaces => IConfiguration, IConfigurationRoot, IConfigurationSection etc.

packages: 
	Microsoft.Extensions.Configuration
	Microsoft.Extensions.Configuration.Json
	Microsoft.Extensions.Configuration.EnvironmentVariables
	Microsoft.Extensions.Configuration.CommandLine
	Microsoft.Extensions.Configuration.Binder
	etc.

Options Pattern: provides mechanism to register and dependency inject a wrapper object with configuration options for another service

package: Microsoft.Extensions.Options


Hosting:
	console => Host
	web app => WebHost
	package: Microsoft.Extensions.Hosting


using LnW.DotNet.PmsApp.Entities;
using LnW.DotNet.PmsApp.Manager;
using LnW.DotNet.PmsApp.Repository;
using LnW.DotNet.PmsApp.Storage;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Console;
using Microsoft.Extensions.Options;
using Microsoft.VisualStudio.Shell.Interop;

namespace LnW.DotNet.PmsApp.UserInterface
{
    internal class Program
    {
        static IHost CreateHost(string[] args)
        {
            HostApplicationBuilder builder = Host.CreateApplicationBuilder(args);

            //Configuration settings
            ConfigurationManager configManager = builder.Configuration;

            configManager
                .SetBasePath(Directory.GetCurrentDirectory())
                .AddJsonFile("appSettings.json", false, true);

            //service registration
            IServiceCollection registry = builder.Services;


            //registering IOptions<IFilePathSetting> types
            registry.Configure<FilePathSetting>(
                fs =>
                {
                    fs.FilePath = configManager.GetRequiredSection("filePathSetting:productFilePath").Value ?? "products.json";
                }
                );

            //if fetching data from categories.json file
            //registry.Configure<FilePathSetting>(
            //    fs =>
            //    {
            //        fs.FilePath = configManager.GetRequiredSection("fileList:categoryFilePath").Value ?? "categories.json";
            //    }
            //    );

            //registering storages
            //storage objects are dependent on IOptions<FileSetting> type objects
            registry.AddScoped<IStorage<Product>, FileStorage<Product>>();
            registry.AddScoped<IStorage<Category>, FileStorage<Category>>();

            //IRepository objects are dependent on IStorage type objects
            registry.AddScoped<IRepository<Product, int>, ProductRepository>();
            registry.AddScoped<IRepository<Category, int>, CategoryRepository>();

            //IManager type objects are dependent on IRepository type objects
            registry.AddScoped<IManager<Product, int>, ProductManager>();
            registry.AddScoped<IManager<Category, int>, CategoryManager>();

            //configuring logger
            ILoggingBuilder loggerBuilder = builder.Logging;
            loggerBuilder
                .AddSimpleConsole(
                    (buildOptions) =>
                    {
                        buildOptions.SingleLine = true;
                        buildOptions.ColorBehavior = LoggerColorBehavior.Enabled;
                        buildOptions.IncludeScopes = true;
                    }
                );

            //finally creating host configured with required configuration providers, services for dependency injection and logger
            IHost host = builder.Build();
            return host;

        }
        private static async Task GetProducts(IServiceProvider provider)
        {
            IManager<Product, int> productManager = provider.GetRequiredService<IManager<Product, int>>();
            IReadOnlyList<Product> products = await productManager.FetchAll();

            products
                .ToList()
                .ForEach(p => Console.WriteLine($"{p.Id} - {p.Name} - {p.Price}"));
        }
        static async Task Main(string[] args)
        {
            /* code with Hosting service*/
            using IHost host = CreateHost(args);
            await GetProducts(host.Services);
            await host.RunAsync();



            /*
         
            //code without Host service

            var configuration = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile("appsettings.json", optional: false, reloadOnChange: true)
            .Build();

            var services = new ServiceCollection();

            services.Configure<FilePathSetting>(filePathSetting => 
                {
                    filePathSetting.FilePath = configuration.GetRequiredSection("filePathSetting:productFilePath").Value ?? "";
                    //for categories
                    //filePathSetting.CategoryFilePath = configuration.GetRequiredSection("filePathSetting:categoryFilePath").Value??"";
                }
            );

            services.AddScoped<IStorage<Product>, FileStorage<Product>>();
            services.AddScoped<IStorage<Category>, FileStorage<Category>>();

            services.AddScoped<IRepository<Product, int>, ProductRepository>();
            services.AddScoped<IRepository<Category, int>, CategoryRepository>();

            services.AddScoped<IManager<Product, int>, ProductManager>();
            services.AddScoped<IManager<Category, int>, CategoryManager>();

            IServiceProvider provider = services.BuildServiceProvider();

            IManager<Product, int> productManager = provider.GetRequiredService<IManager<Product, int>>();

            var products = await productManager.FetchAll()
            products
                .ToList()
                .ForEach(p => Console.WriteLine($"{p.Id} - {p.Name} - {p.Price}"));
            */
        }


    }
}

	
